# Hikyuu 复权数据计算逻辑详解

## 1. 引言

在股票市场中，由于送股、配股、增发、派息、缩股等因素，股价常常会发生变动，导致K线图出现跳空缺口，使得技术指标失真。为了保持股价走势的连续性和可比性，需要对历史股价进行复权处理。本文档旨在详细解释 Hikyuu 量化交易框架中复权数据的计算逻辑。

## 2. 数据来源

Hikyuu 的复权数据计算依赖于权息数据。这些数据通常来源于外部数据源（如通达信），并通过 `ImportWeightToSqliteTask.py` 和 `pytdx_weight_to_sqlite.py` 等脚本导入到本地数据库的 `StkWeight` 表中。

`StkWeight` 对象（对应表中的记录）主要包含以下关键字段：

*   `datetime`: 权息日期（除权除息日）。
*   `countAsGift`: 每10股送红股数。
*   `countForSell`: 每10股配股数。
*   `priceForSell`: 配股价（每股）。
*   `bonus`: 每10股派发现金红利（元）。
*   `increasement`: 每10股增发新股数。
*   `totalCount`: 总股本（股）。
*   `freeCount`: 流通股本（股）。
*   `suogu`: 缩股比例。例如，10股缩为5股，则此值为 0.5。若无缩股，此值为0或1。

这些字段是后续复权计算的基础。

## 3. 复权类型

Hikyuu 在 C++ 核心中通过 `KQuery::RecoverType` 枚举定义了不同的复权类型：

*   `NO_RECOVER`: 不复权，使用原始股价数据。
*   `FORWARD`: 前向复权，以除权后的股价为基准，调整除权前的股价。
*   `BACKWARD`: 后向复权，以除权前的股价为基准，调整除权后的股价。
*   `EQUAL_FORWARD`: 等比前向复权，计算复权比例，调整除权前的股价。
*   `EQUAL_BACKWARD`: 等比后向复权，计算复权比例，调整除权后的股价。

## 4.核心实现：`KDataImp.cpp`

复权计算的核心逻辑位于 `hikyuu_cpp/hikyuu/KDataImp.cpp` 文件中。

当通过 `Stock::getKData(KQuery)` 获取K线数据并指定了复权类型时，`KDataImp` 类的构造函数 `KDataImp(const Stock& stock, const KQuery& query)` 会被调用。

其主要流程如下：

1.  获取指定日期范围内的原始K线数据列表 `m_buffer`。
2.  如果 `query.recoverType() == KQuery::NO_RECOVER`，则直接返回原始数据。
3.  如果查询的K线类型为周线、月线等日线以上周期，则调用 `_recoverForUpDay()` 进行特殊处理（先获取日线复权数据再合成）。
4.  根据 `query.recoverType()` 的具体值，通过 `switch` 语句调用相应的私有复权计算函数：
    *   `_recoverForward()`
    *   `_recoverBackward()`
    *   `_recoverEqualForward()`
    *   `_recoverEqualBackward()`

这些私有函数内部会调用 `m_stock.getWeight(start_date, end_date)` 获取相应时间段内的 `StockWeightList`（权息记录列表），并遍历这些记录来调整 `m_buffer` 中的开盘价、最高价、最低价、收盘价（OHLC）。

## 5. 各复权类型计算详解

以下分别详细说明四种主要复权类型的计算方法。

### 5.1. `_recoverBackward()` - 后向复权

*   **目的**：保持历史价格不变，将除权除息后的价格向上调整，使得K线连续。
*   **处理顺序**：从权息列表的最新记录开始，逆序遍历至最旧记录。
*   **影响范围**：每次遇到一个权息日，调整该权息日（含）之后的所有K线价格。
*   **公式 (来源于代码注释)**：
    `复权后价格 = 复权前价格 × (1 + 流通股份变动比例) - 配(新)股价格 × 流通股份变动比例 + 现金红利`
*   **代码实现关键点**：
    1.  `change = 0.1 * (送股数 + 配股数 + 增发数)`：计算每股的流通股份变动比例。
    2.  `denominator = 1.0 + change`：即 `(1 + 流通股份变动比例)`。
    3.  `temp = 0.1 * 现金红利 - 配股价 * change`：即 `(每股现金红利 - 每股配股价 * 流通股份变动比例)`。
    4.  应用调整：`新价格 = 旧价格 * denominator + temp`。
*   **缩股 (`suogu`) 处理**：
    如果 `weightIter->suogu()` (缩股比例) 不为0 (例如，10缩5，`suogu`为0.5)：
    *   `denominator = weightIter->suogu()`
    *   `temp = 0.0`
    *   应用调整：`新价格 = 旧价格 * suogu`。
        *(注：此处原文代码逻辑似乎是将价格乘上缩股比例，对于后复权，价格应抬高，例如10缩5，后续价格应除以0.5。此处的实现可能是基于特定的“缩股比例”定义，或者后复权的缩股逻辑是反向的，即“复原”缩股的影响。实际效果需要结合数据验证。常见的后复权缩股是将后续价格除以缩股比例，如 `新价格 = 旧价格 / suogu`)*

### 5.2. `_recoverEqualBackward()` - 等比后向复权

*   **目的**：与后向复权类似，但使用复权比例进行调整。
*   **处理顺序与影响范围**：同 `_recoverBackward`。
*   **公式 (来源于代码注释)**：
    `复权后价格 = 复权前价格 ÷ 复权率`
    `复权率 = {[(股权登记日收盘价 - 现金红利) + 配(新)股价格 × 流通股份变动比例] ÷ (1 + 流通股份变动比例)} ÷ 股权登记日收盘价`
*   **代码实现关键点**：
    1.  `closePrice = m_buffer[pre_pos - 1].closePrice`：获取股权登记日（除权日前一天）的收盘价。
    2.  `change` (流通股份变动比例) 计算同上。
    3.  `denominator_formula_part = 1.0 + change`：即 `(1 + 流通股份变动比例)`。
    4.  `temp_formula_part = closePrice + 配股价 * change - 0.1 * 现金红利`：代表分子中的 `股权登记日收盘价 + 配(新)股价格 × 流通股份变动比例 - 现金红利` 部分。
    5.  计算调整系数 `k = (denominator_formula_part * closePrice) / temp_formula_part`。
        注意，此 `k` 相当于公式中的 `1 / 复权率`。
    6.  应用调整：`新价格 = 旧价格 * k`。
*   **缩股 (`suogu`) 处理**：
    如果 `weightIter->suogu()` 不为0：
    *   `k = weightIter->suogu()` (此处的 `k` 对应缩股比例本身)
    *   应用调整：`新价格 = 旧价格 * suogu`。
        *(注：同上，此处的缩股处理对于后复权，价格应抬高，等比后复权的常见做法是 `新价格 = 旧价格 / 复权率(含缩股影响)`。若 `suogu` 直接作为乘数，则价格降低。)*

### 5.3. `_recoverForward()` - 前向复权

*   **目的**：保持当前（除权后）价格不变，将除权除息前的历史价格向下调整。
*   **处理顺序**：从权息列表的最旧记录开始，顺序遍历至最新记录。
*   **影响范围**：每次遇到一个权息日，调整该权息日之前的所有K线价格。
*   **公式 (来源于代码注释)**：
    `复权后价格 = [(复权前价格 - 现金红利) + 配(新)股价格 × 流通股份变动比例] ÷ (1 + 流通股份变动比例)`
*   **代码实现关键点**：
    1.  `change` (流通股份变动比例) 计算同上。
    2.  `denominator = 1.0 + change`：即分母 `(1 + 流通股份变动比例)`。
    3.  `temp = 配股价 * change - 0.1 * 现金红利`：代表 `配(新)股价格 × 流通股份变动比例 - 现金红利`。
    4.  应用调整：`新价格 = (旧价格 + temp) / denominator`。
        这等价于 `(旧价格 - (-temp)) / denominator`，而 `-temp` 即为 `现金红利 - 配股价 * 流通股份变动比例`，符合公式分子部分。
*   **缩股 (`suogu`) 处理**：
    如果 `weightIter->suogu()` 不为0：
    *   `denominator = weightIter->suogu()`
    *   `temp = 0.0`
    *   应用调整：`新价格 = 旧价格 / suogu`。对于10缩5 (`suogu=0.5`)，历史价格除以0.5（即乘以2），正确。

### 5.4. `_recoverEqualForward()` - 等比前向复权

*   **目的**：与前向复权类似，但使用复权比例进行调整。
*   **处理顺序与影响范围**：同 `_recoverForward`。
*   **公式 (来源于代码注释)**：
    `复权后价格 = 复权前价格 * 复权率`
    `复权率 = {[(股权登记日收盘价 - 现金红利) + 配(新)股价格 × 流通股份变动比例] ÷ (1 + 流通股份变动比例)} ÷ 股权登记日收盘价`
*   **代码实现关键点**：
    1.  `closePrice = kdata[pre_pos - 1].closePrice`：获取股权登记日的收盘价 (使用 `kdata` 副本避免同一天多次权息问题)。
    2.  `change` (流通股份变动比例) 计算同上。
    3.  `denominator_formula_part = 1.0 + change`。
    4.  `temp = 配股价 * change - 0.1 * 现金红利`。
    5.  计算复权率 `k = (closePrice + temp) / (denominator_formula_part * closePrice)`。
        分子 `closePrice + temp` 对应 `股权登记日收盘价 + (配股价*变动比例 - 现金红利)`。
        分母 `denominator_formula_part * closePrice` 对应 `(1 + 变动比例) * 股权登记日收盘价`。
    6.  应用调整：`新价格 = 旧价格 * k`。
*   **缩股 (`suogu`) 处理**：
    如果 `weightIter->suogu()` 不为0：
    *   `k = 1.0 / weightIter->suogu()`。
    *   应用调整：`新价格 = 旧价格 * k`。对于10缩5 (`suogu=0.5`)，历史价格乘以 `1/0.5=2`，正确。

## 6. 非日线周期的复权处理 (`_recoverForUpDay()`)

对于周线、月线、季度线、半年线、年线等非日线周期的K线，Hikyuu 的 `_recoverForUpDay()` 函数采用以下策略：

1.  确定目标周期K线数据的时间范围。
2.  获取该时间范围内的、经过相应复权类型处理的 **日线** K数据。
3.  遍历目标周期的每根K线，根据其对应的日线数据（在同一复权类型下），合成该目标周期K线的OHLCV（开高低收、成交量、成交额）等数据。

这意味着非日线周期的复权是基于日线复权数据再加工得到的，保证了不同周期下复权逻辑的一致性。

## 7. 总结

Hikyuu 通过在 C++ 层面实现复权逻辑，确保了计算效率。它能够处理多种常见的权息事件，并提供前复权、后复权、等比前复权、等比后复权四种主要的复权方式。理解这些复权算法的细节，有助于用户更准确地使用 Hikyuu 进行量化分析和策略回测。

*(注意：文档中关于后复权中缩股 (`suogu`) 部分的解释，指出了代码实现与常见理论可能存在的差异，具体行为建议通过实际数据进行验证。)*

# Hikyuu 停牌复牌数据处理机制分析

Hikyuu 作为一款量化交易框架，在处理股票数据时，停牌和复牌是一个不可避免的场景。本文档将详细分析 Hikyuu 是如何处理停牌复牌数据的，包括数据来源、数据存储以及核心处理逻辑。

## 核心思想：依赖K线数据本身

Hikyuu 在设计上并没有为每个股票的每一天维护一个明确的“是否停牌”的标志位。相反，它依赖于其加载和使用的K线数据本身的特性来间接反映停牌状态。这意味着：

*   **如果某股票在某交易日停牌，导致数据源中没有该日的K线记录，那么 Hikyuu 在获取该日数据时也会表现为数据缺失。**
*   **如果数据源中停牌日的K线记录存在，但其成交量为0（价格通常维持停牌前状态），那么 Hikyuu 加载后的K线记录也会体现这一特征。**

这种设计简化了数据管理的复杂性，将停牌状态的处理下沉到数据层面。

## 数据来源

Hikyuu 支持从多种数据源获取数据，常见的包括：

1.  **本地数据文件**：
    *   **通达信 (TDX)**：用户可以通过通达信客户端下载日线、分钟线等数据。Hikyuu 提供了工具（如 `pytdx` 接口的封装 `PytdxKDataDriver`，以及直接读取 `.day` 等文件的工具）来导入这些数据。
        *   对于停牌日，通达信导出的数据文件通常表现为：
            *   当日没有数据条目。
            *   当日有数据条目，但成交量为0，价格（开、高、低、收）维持在停牌前的水平或为0。
    *   **CSV 文件**：用户也可以自行准备CSV格式的K线数据导入。

2.  **数据库**：
    *   Hikyuu 支持将数据存储在如 MySQL、SQLite 等数据库中。停牌日的表现同样取决于导入数据库前数据的处理方式。

3.  **实时行情接口**（主要用于实盘，但历史数据获取也可能涉及）：
    *   如果对接了实时行情API，停牌股票在交易时段通常不会有新的tick数据或bar数据更新，或者行情接口会明确标记其交易状态。

**关键点**：无论数据来源如何，Hikyuu 处理停牌的基础在于这些源数据如何表示停牌。

## 数据存储

Hikyuu 主要使用以下方式存储行情数据：

1.  **HDF5 文件**：这是 Hikyuu 推荐的高效本地数据存储格式。K线数据（日线、分钟线）、财务数据、权息数据等都可以被导入和存储在 HDF5 文件中（通常是 `stock.h5` 或按市场划分的多个 `*.h5` 文件）。
    *   停牌日的数据，如果原始数据中缺失，则 HDF5 文件中对应日期也不会有记录。
    *   如果原始数据中停牌日成交量为0，HDF5 文件中对应记录的成交量也会是0。

2.  **SQLite 数据库**：主要用于存储元数据信息，如：
    *   股票代码表 (`stock` 表)
    *   市场信息 (`market` 表)
    *   权息数据 (`stkweight` 表)
    *   交易日历 (`tradedate` 表)

    **注意**：SQLite 中通常不直接存储每日的停牌状态，而是通过K线数据（存储在HDF5或数据库K线表中）来反映。

## 核心处理逻辑

Hikyuu 的核心C++层通过 `Stock` 和 `KData` 对象来管理和提供K线数据。

### `Stock` 对象

`Stock` 对象代表一只具体的证券。

*   **数据加载**：当需要获取某只股票的K线数据时，`Stock` 对象会通过其内部的**数据驱动** (Data Driver) 从配置的数据源（如HDF5文件、数据库）中加载数据。
*   **K线缓存**：`Stock` 对象内部可能会缓存已加载的K线数据，以提高后续访问效率。
*   **`getKData(KQuery)` 方法**：这是获取K线数据的主要接口。它接受一个 `KQuery` 对象作为参数，该对象指定了查询条件（如起止日期、K线类型、复权方式）。
    *   如果查询的时间段内包含停牌日，且这些停牌日在数据源中没有记录，则返回的 `KData` 对象将不包含这些日期的K线。
    *   如果停牌日的记录存在但成交量为0，则 `KData` 对象会包含这些记录，其 `volume` 字段为0。
*   **`getKRecord(datetime, ktype)` 或 `getKRecord(pos, ktype)`**：获取单个K线记录。
    *   如果请求的日期或位置由于停牌而没有数据，通常会返回一个无效或空的 `KRecord`（例如，在C++中可能是 `Null<KRecord>()`，或在Python层返回 `None` 或一个所有值为0/NaN的记录）。

### `KData` 对象

`KData` 对象是 `Stock` 对象根据特定 `KQuery` 返回的K线数据集合。

*   **数据视图**：`KData` 可以看作是原始K线数据的一个切片或视图。
*   **访问K线记录**：可以通过索引或日期访问 `KData` 中的 `KRecord`。
    *   `kdata[datetime]` 或 `kdata.get_krecord(datetime)`：如果该日期停牌且无数据，尝试访问将导致获取到一个无效记录（如C++中的 `ms_null_krecord`）或在Python层引发错误/返回特殊值，具体取决于封装。
    *   `kdata.empty()` 或 `len(kdata)`：可以检查获取到的K线数据序列是否为空。
*   **与交易日历的关系**：Hikyuu拥有全局的交易日历。即使某天是市场的交易日，如果特定股票在该日停牌，那么该股票的 `KData` 在该日期可能依然没有数据。

## 回测与实盘中的影响

停牌复牌状态对策略回测和实盘交易有直接影响：

1.  **交易执行**：
    *   如果策略在某股票停牌日发出买入或卖出信号，该交易指令通常无法执行。回测引擎需要正确处理这种情况，不应错误地将停牌日的订单视为已成交。
    *   复牌首日的价格行为（如涨跌停、巨量成交）也需要策略特别关注。

2.  **指标计算**：
    *   技术指标依赖于连续的K线数据。停牌会导致数据断层。
    *   如果停牌日的K线以0成交量、不变价格的形式存在，指标计算时需要注意这些伪数据点可能带来的影响（例如MA等均线指标会被拉平）。Hikyuu 的指标库在设计时会考虑如何处理无效值（如 `NaN`）。

3.  **持仓管理**：
    *   股票停牌期间，持仓的市值通常按停牌前最后一个交易日的收盘价计算。

## 用户如何应对

1.  **保证数据质量**：确保使用的数据源能正确反映停牌信息（无论是数据缺失还是成交量为0）。在数据导入和清洗阶段需要特别注意。
2.  **策略鲁棒性**：
    *   策略逻辑应能处理获取不到数据或获取到无效数据（如成交量为0）的情况。
    *   避免在可能停牌的股票上执行过于依赖连续交易的逻辑，或为停牌情况设计备选方案。
3.  **复牌处理**：部分策略可能会针对复牌后的特定行情（如补涨、补跌）设计交易逻辑。

## 结论

Hikyuu 通过依赖K线数据本身来处理停牌复牌，而不是维护一个显式的状态标记。这种方式将停牌的判断与数据获取紧密耦合。用户在使用 Hikyuu 进行量化分析和交易时，需要理解其数据处理机制，并确保数据源的准确性以及策略对停牌情况的适应性。

*(注意：文档中关于后复权中缩股 (`suogu`) 部分的解释，指出了代码实现与常见理论可能存在的差异，具体行为建议通过实际数据进行验证。)*

# Hikyuu 交易日历的确定机制

Hikyuu 系统中交易日历的确定方式非常直接，它紧密依赖于市场指数的实际K线数据。以下是其核心逻辑：

1.  **`StockManager::getTradingCalendar(query, market)`**: 
    *   当外部请求获取某个市场（如 “SH” - 上海）的交易日历时，会调用 `StockManager` 的 `getTradingCalendar` 方法。
    *   此方法首先获取指定市场的 `MarketInfo` 对象，该对象包含了市场的代码，例如上海市场的指数代码 “000001”。
    *   然后，它构造出该市场指数的 `Stock` 对象（例如 `SH000001`）。
    *   最终，它调用这个指数 `Stock` 对象的 `getDatetimeList(query)` 方法来获取交易日列表。

2.  **`Stock::getDatetimeList(query)`**: 
    *   这个方法的核心任务是调用 `Stock::getKRecordList(query)` 来获取该股票（在此场景下是市场指数）在指定查询条件下的K线数据列表 (`KRecordList`)。
    *   获取到K线数据列表后，它会遍历这个列表，并提取每条K线记录中的日期时间 (`k.datetime`)。
    *   这些提取出来的日期时间就构成了指定查询范围内的交易日历。

3.  **`Stock::getKRecordList(query)`**: 
    *   此函数负责从数据源获取K线记录。它有两种主要的数据获取路径：
        *   **内存缓存**: 如果请求的K线数据（特别是常用的日线数据）已经被加载到内存缓存中，则直接从缓存读取，以提高性能。
        *   **数据驱动 (KDataDriver)**: 如果数据不在缓存中，则通过配置的K线数据驱动（如 SQLite、MySQL、HDF5 等驱动）从数据库或数据文件中实际获取K线数据。

**核心结论：**

Hikyuu 的交易日历是**基于对应市场指数的实际K线数据日期**生成的。简单来说，如果某一天市场指数有K线数据，那么这一天就被认为是该市场的交易日；反之，如果指数在某天没有K线数据，则该天不被视为交易日。

**关于 `holiday` 节假日表：**

Hikyuu 系统中确实存在一个 `holiday` 表，其数据通常通过 `hikyuu/data/common.py` 中的 `get_new_holidays()` 函数从 `https://www.tdx.com.cn/url/holiday/` 获取并存入数据库（如 SQLite 的 `holiday` 表）。

*   这些节假日数据被加载到 `StockManager` 的 `m_holidays` 集合中。
*   `StockManager::isHoliday(Datetime d)` 方法可以用来查询某一天是否为已定义的节假日。

然而，需要明确的是，这个 `holiday` 表和 `m_holidays` 集合**并不直接用于** `StockManager::getTradingCalendar` 生成交易日历的过程。交易日历的生成完全依赖于上述的市场指数K线数据。
`holiday` 表的主要作用可能包括：
*   供策略逻辑或其他系统模块查询特定日期是否为公布的节假日。
*   在数据导入或清洗过程中，辅助校验K线数据的合理性（例如，检查是否在已知节假日出现了K线数据）。

这种设计使得交易日历的确定非常务实：市场指数实际交易的那些天，即为市场的交易日。
