# Hikyuu 复权数据计算逻辑详解

## 1. 引言

在股票市场中，由于送股、配股、增发、派息、缩股等因素，股价常常会发生变动，导致K线图出现跳空缺口，使得技术指标失真。为了保持股价走势的连续性和可比性，需要对历史股价进行复权处理。本文档旨在详细解释 Hikyuu 量化交易框架中复权数据的计算逻辑。

## 2. 数据来源

Hikyuu 的复权数据计算依赖于权息数据。这些数据通常来源于外部数据源（如通达信），并通过 `ImportWeightToSqliteTask.py` 和 `pytdx_weight_to_sqlite.py` 等脚本导入到本地数据库的 `StkWeight` 表中。

`StkWeight` 对象（对应表中的记录）主要包含以下关键字段：

*   `datetime`: 权息日期（除权除息日）。
*   `countAsGift`: 每10股送红股数。
*   `countForSell`: 每10股配股数。
*   `priceForSell`: 配股价（每股）。
*   `bonus`: 每10股派发现金红利（元）。
*   `increasement`: 每10股增发新股数。
*   `totalCount`: 总股本（股）。
*   `freeCount`: 流通股本（股）。
*   `suogu`: 缩股比例。例如，10股缩为5股，则此值为 0.5。若无缩股，此值为0或1。

这些字段是后续复权计算的基础。

## 3. 复权类型

Hikyuu 在 C++ 核心中通过 `KQuery::RecoverType` 枚举定义了不同的复权类型：

*   `NO_RECOVER`: 不复权，使用原始股价数据。
*   `FORWARD`: 前向复权，以除权后的股价为基准，调整除权前的股价。
*   `BACKWARD`: 后向复权，以除权前的股价为基准，调整除权后的股价。
*   `EQUAL_FORWARD`: 等比前向复权，计算复权比例，调整除权前的股价。
*   `EQUAL_BACKWARD`: 等比后向复权，计算复权比例，调整除权后的股价。

## 4.核心实现：`KDataImp.cpp`

复权计算的核心逻辑位于 `hikyuu_cpp/hikyuu/KDataImp.cpp` 文件中。

当通过 `Stock::getKData(KQuery)` 获取K线数据并指定了复权类型时，`KDataImp` 类的构造函数 `KDataImp(const Stock& stock, const KQuery& query)` 会被调用。

其主要流程如下：

1.  获取指定日期范围内的原始K线数据列表 `m_buffer`。
2.  如果 `query.recoverType() == KQuery::NO_RECOVER`，则直接返回原始数据。
3.  如果查询的K线类型为周线、月线等日线以上周期，则调用 `_recoverForUpDay()` 进行特殊处理（先获取日线复权数据再合成）。
4.  根据 `query.recoverType()` 的具体值，通过 `switch` 语句调用相应的私有复权计算函数：
    *   `_recoverForward()`
    *   `_recoverBackward()`
    *   `_recoverEqualForward()`
    *   `_recoverEqualBackward()`

这些私有函数内部会调用 `m_stock.getWeight(start_date, end_date)` 获取相应时间段内的 `StockWeightList`（权息记录列表），并遍历这些记录来调整 `m_buffer` 中的开盘价、最高价、最低价、收盘价（OHLC）。

## 5. 各复权类型计算详解

以下分别详细说明四种主要复权类型的计算方法。

### 5.1. `_recoverBackward()` - 后向复权

*   **目的**：保持历史价格不变，将除权除息后的价格向上调整，使得K线连续。
*   **处理顺序**：从权息列表的最新记录开始，逆序遍历至最旧记录。
*   **影响范围**：每次遇到一个权息日，调整该权息日（含）之后的所有K线价格。
*   **公式 (来源于代码注释)**：
    `复权后价格 = 复权前价格 × (1 + 流通股份变动比例) - 配(新)股价格 × 流通股份变动比例 + 现金红利`
*   **代码实现关键点**：
    1.  `change = 0.1 * (送股数 + 配股数 + 增发数)`：计算每股的流通股份变动比例。
    2.  `denominator = 1.0 + change`：即 `(1 + 流通股份变动比例)`。
    3.  `temp = 0.1 * 现金红利 - 配股价 * change`：即 `(每股现金红利 - 每股配股价 * 流通股份变动比例)`。
    4.  应用调整：`新价格 = 旧价格 * denominator + temp`。
*   **缩股 (`suogu`) 处理**：
    如果 `weightIter->suogu()` (缩股比例) 不为0 (例如，10缩5，`suogu`为0.5)：
    *   `denominator = weightIter->suogu()`
    *   `temp = 0.0`
    *   应用调整：`新价格 = 旧价格 * suogu`。对于10缩5（`suogu=0.5`），相当于将后续价格乘以0.5。
        *(注：此处原文代码逻辑似乎是将价格乘上缩股比例，对于后复权，价格应抬高，例如10缩5，后续价格应除以0.5。此处的实现可能是基于特定的“缩股比例”定义，或者后复权的缩股逻辑是反向的，即“复原”缩股的影响。实际效果需要结合数据验证。常见的后复权缩股是将后续价格除以缩股比例，如 `新价格 = 旧价格 / suogu`)*

### 5.2. `_recoverEqualBackward()` - 等比后向复权

*   **目的**：与后向复权类似，但使用复权比例进行调整。
*   **处理顺序与影响范围**：同 `_recoverBackward`。
*   **公式 (来源于代码注释)**：
    `复权后价格 = 复权前价格 ÷ 复权率`
    `复权率 = {[(股权登记日收盘价 - 现金红利) + 配(新)股价格 × 流通股份变动比例] ÷ (1 + 流通股份变动比例)} ÷ 股权登记日收盘价`
*   **代码实现关键点**：
    1.  `closePrice = m_buffer[pre_pos - 1].closePrice`：获取股权登记日（除权日前一天）的收盘价。
    2.  `change` (流通股份变动比例) 计算同上。
    3.  `denominator_formula_part = 1.0 + change`：即 `(1 + 流通股份变动比例)`。
    4.  `temp_formula_part = closePrice + 配股价 * change - 0.1 * 现金红利`：代表分子中的 `股权登记日收盘价 + 配(新)股价格 × 流通股份变动比例 - 现金红利` 部分。
    5.  计算调整系数 `k = (denominator_formula_part * closePrice) / temp_formula_part`。
        注意，此 `k` 相当于公式中的 `1 / 复权率`。
    6.  应用调整：`新价格 = 旧价格 * k`。
*   **缩股 (`suogu`) 处理**：
    如果 `weightIter->suogu()` 不为0：
    *   `k = weightIter->suogu()` (此处的 `k` 对应缩股比例本身)
    *   应用调整：`新价格 = 旧价格 * suogu`。
        *(注：同上，此处的缩股处理对于后复权，价格应抬高，等比后复权的常见做法是 `新价格 = 旧价格 / 复权率(含缩股影响)`。若 `suogu` 直接作为乘数，则价格降低。)*

### 5.3. `_recoverForward()` - 前向复权

*   **目的**：保持当前（除权后）价格不变，将除权除息前的历史价格向下调整。
*   **处理顺序**：从权息列表的最旧记录开始，顺序遍历至最新记录。
*   **影响范围**：每次遇到一个权息日，调整该权息日之前的所有K线价格。
*   **公式 (来源于代码注释)**：
    `复权后价格 = [(复权前价格 - 现金红利) + 配(新)股价格 × 流通股份变动比例] ÷ (1 + 流通股份变动比例)`
*   **代码实现关键点**：
    1.  `change` (流通股份变动比例) 计算同上。
    2.  `denominator = 1.0 + change`：即分母 `(1 + 流通股份变动比例)`。
    3.  `temp = 配股价 * change - 0.1 * 现金红利`：代表 `配(新)股价格 × 流通股份变动比例 - 现金红利`。
    4.  应用调整：`新价格 = (旧价格 + temp) / denominator`。
        这等价于 `(旧价格 - (-temp)) / denominator`，而 `-temp` 即为 `现金红利 - 配股价 * 流通股份变动比例`，符合公式分子部分。
*   **缩股 (`suogu`) 处理**：
    如果 `weightIter->suogu()` 不为0：
    *   `denominator = weightIter->suogu()`
    *   `temp = 0.0`
    *   应用调整：`新价格 = 旧价格 / suogu`。对于10缩5 (`suogu=0.5`)，历史价格除以0.5（即乘以2），正确。

### 5.4. `_recoverEqualForward()` - 等比前向复权

*   **目的**：与前向复权类似，但使用复权比例进行调整。
*   **处理顺序与影响范围**：同 `_recoverForward`。
*   **公式 (来源于代码注释)**：
    `复权后价格 = 复权前价格 * 复权率`
    `复权率 = {[(股权登记日收盘价 - 现金红利) + 配(新)股价格 × 流通股份变动比例] ÷ (1 + 流通股份变动比例)} ÷ 股权登记日收盘价`
*   **代码实现关键点**：
    1.  `closePrice = kdata[pre_pos - 1].closePrice`：获取股权登记日的收盘价 (使用 `kdata` 副本避免同一天多次权息问题)。
    2.  `change` (流通股份变动比例) 计算同上。
    3.  `denominator_formula_part = 1.0 + change`。
    4.  `temp = 配股价 * change - 0.1 * 现金红利`。
    5.  计算复权率 `k = (closePrice + temp) / (denominator_formula_part * closePrice)`。
        分子 `closePrice + temp` 对应 `股权登记日收盘价 + (配股价*变动比例 - 现金红利)`。
        分母 `denominator_formula_part * closePrice` 对应 `(1 + 变动比例) * 股权登记日收盘价`。
    6.  应用调整：`新价格 = 旧价格 * k`。
*   **缩股 (`suogu`) 处理**：
    如果 `weightIter->suogu()` 不为0：
    *   `k = 1.0 / weightIter->suogu()`。
    *   应用调整：`新价格 = 旧价格 * k`。对于10缩5 (`suogu=0.5`)，历史价格乘以 `1/0.5=2`，正确。

## 6. 非日线周期的复权处理 (`_recoverForUpDay()`)

对于周线、月线、季度线、半年线、年线等非日线周期的K线，Hikyuu 的 `_recoverForUpDay()` 函数采用以下策略：

1.  确定目标周期K线数据的时间范围。
2.  获取该时间范围内的、经过相应复权类型处理的 **日线** K数据。
3.  遍历目标周期的每根K线，根据其对应的日线数据（在同一复权类型下），合成该目标周期K线的OHLCV（开高低收、成交量、成交额）等数据。

这意味着非日线周期的复权是基于日线复权数据再加工得到的，保证了不同周期下复权逻辑的一致性。

## 7. 总结

Hikyuu 通过在 C++ 层面实现复权逻辑，确保了计算效率。它能够处理多种常见的权息事件，并提供前复权、后复权、等比前复权、等比后复权四种主要的复权方式。理解这些复权算法的细节，有助于用户更准确地使用 Hikyuu 进行量化分析和策略回测。

*(注意：文档中关于后复权中缩股 (`suogu`) 部分的解释，指出了代码实现与常见理论可能存在的差异，具体行为建议通过实际数据进行验证。)*
